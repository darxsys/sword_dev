Dario:

tablica na GPU:

sad treba jos napisati kernel. Kernelu se proslijedi array automata koji u sebi sadrze sve potrebno za izvrsavanje.

Treba napraviti da svaki thread uzme jedan automat, popuni kandidate pomocu prijelaza u device vector i onda se taj device vector
vrati na host u host_vector i to je to.

Robert:
slijedno kreiranje i brisanje automata. po potrebi


prije GPU:

1) izracunati prosjecno koliki je postotak broja stanja u odnosu na maksimalni
    # seedova u kveriju / broj mogucih (max_seed). poseban program.

broj stanja / maks broj stanja i toto.


do 31.10.:

1) provjeriti gornju granicu za 2 cetvorke
2) probati hash
3) postotak redukcije baze s jednim hitom na cetvorkama





Table automaton:

1) Creation of the table could be problematic. How to correctly allocate table size? Is that even possible?
Maybe reallocation to double the current size and then reallocation to the final size if
the allocated part ends up being bigger? Is this really amortized O(1)? Can we go faster?

Well, worst case is to allocate queryLen - seedLen + 1 states and then just reallocate in the end to the
real size? Maybe this is the best. This will waste a lot of memory during the process, maybe not even be
possible for huge strings. 

2) Functions:
Doing transitions.
Adding another table for hits for every state.



